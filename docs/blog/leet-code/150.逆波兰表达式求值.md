---
title: 150.逆波兰表达式求值
date: 2024-01-11
tags: 
 - 栈
 - 数组
 - 数学
categories:
 - 力扣每日一题
---

# 150.逆波兰表达式求值

**难度：中等**

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

**提示：**

- `1 <= tokens.length <= 104`
- `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

## 解题思路

递归就是用栈来实现的，所以 **栈与递归之间在某种程度上是可以转换的**。

本题中，其实 **逆波兰表达式相当于是二叉树中的后序遍历**，但我们没有必要从二叉树的角度去解决这个题，只要知道逆波兰表达式是用后序遍历的方式把二叉树序列化了，就可以了。

本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么这和 **1047.删除字符串中的所有相邻重复项** 就非常像了。

所有的 **表达式计算** 问题都离不开 **栈**。

对逆波兰表达式求值的过程是：

1. 如果遇到数字就进栈；
2. 如果遇到运算符，就从栈顶弹出两个数字分别为 num2（栈顶）、num1（栈中的第二个元素）；计算 `num1 运算符 num2`

逆波兰表达式的代码实现很简单，用一个栈就能解决。

而栈的实现通常有两种：

1. 使用数组模拟栈
2. 使用系统自带的栈结构

## 我的代码

```java
public int evalRPN(String[] tokens) {
    // 初始化栈
    Deque<Integer> stack = new LinkedList<Integer>();
    int lt = tokens.length;
    // 遍历逆波兰表达式字符串
    for (int i = 0; i < lt; i++) {
        String x = tokens[i];
        if ("+".equals(x)) {// Java 中不能使用 == 判断字符串是否相等，并且在工作中为了避免空指针异常，我们习惯把常量字符串放在equal前面
            int rightNumber = stack.pop();
            int leftNumber = stack.pop();
            stack.push(leftNumber + rightNumber); 
        } else if ("-".equals(x)) {
            int rightNumber = stack.pop();
            int leftNumber = stack.pop();
            stack.push(leftNumber - rightNumber);
        } else if ("*".equals(x)) {
           int rightNumber = stack.pop();
           int leftNumber = stack.pop();
           stack.push(leftNumber * rightNumber);
        } else if ("/".equals(x)) {
            int rightNumber = stack.pop();
            int leftNumber = stack.pop();
            stack.push(leftNumber / rightNumber);
        } else {// 遇到数字就进栈
            stack.push(Integer.valueOf(x));
        }
    }
    // 返回栈中最后剩余的唯一的元素
    return stack.pop();
}
```

时间复杂度：O(n)

空间复杂度：O(n)

## 总结

栈的实现通常有两种：

1. 使用数组模拟栈
2. 使用系统自带的栈结构

